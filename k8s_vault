#!/bin/bash

###################################
#           Variables
###################################
ROOT_DIR="secret"
PATH_TO_SECRET="wp/db"
USERNAME="user"
PASSWORD="pass"
GREEN='\033[0;32m'  
NC='\033[0m'
YELLOW='\033[0;33m'

NAMESPACE="vault"
SERVICE_ACCOUNT="vault-mariadb-sa"
ACCESS_ROLE="vault-mariadb-ar"
POLICY_NAME="vault-mariadb-policy"

function add_namespace {
    
    echo -e "\n${YELLOW}* Add new namespace and choose it by default${NC}"
    kubectl create ns $NAMESPACE
    kubectl config set-context --current --namespace=$NAMESPACE

}

function add_repos {
    echo -e "\n${YELLOW}* Add repo hashicorp${NC}"
    helm repo add hashicorp https://helm.releases.hashicorp.com
    
    echo -e "${YELLOW}* Update repo list${NC}"
    helm repo update
}

function install_consul {
    echo -e "\n${YELLOW}* Install consul with values from helm-consul-values.yml${NC}"
    helm install consul hashicorp/consul --values helm-consul-values.yml
    
    echo -e "${YELLOW}* Verify installation${NC}"
    kubectl wait --timeout=180s --for=condition=Ready $(kubectl get pod --selector=app=consul -o name)
}

function install_vault {
    echo -e "\n${YELLOW}* Install vault with values from helm-vault-values.yml${NC}"
    helm install vault hashicorp/vault --values helm-vault-values.yml
    
    echo -e "${YELLOW}* Verify installation${NC}"
    kubectl wait --timeout=180s --for=condition=Ready $(kubectl get pod --selector=app.kubernetes.io/name=vault-agent-injector -o name)
}

function init_vault {
    
    kubectl exec --stdin=true  --tty=true vault-0 -- vault operator  init -status 1> /dev/null
  
    if [ "$?" -ne "0" ]; then
      echo -e "\n${YELLOW}* Init vault${NC}"
      kubectl exec vault-0 -- vault operator init -key-shares=1 -key-threshold=1 -format=json > cluster-keys.json
      echo -e "${YELLOW}* Vault keys have saved in cluster-keys.json.{NC}"
    else 
      echo -e "\nVault was already initialized${NC}"
    fi
}

function unseal_vaults  {
    kubectl exec --stdin=true  --tty=true vault-0 -- vault operator key-status 2> 1 >/dev/null
    if [ "$?" -ne "0" ]; then
        echo -e "\n${YELLOW}* Get vault unseal key${NC}"
        VAULT_UNSEAL_KEY=$(cat cluster-keys.json | jq -r ".unseal_keys_b64[]")
        echo -e "${YELLOW}* Unseal all vaults${NC}"
            for i in {0..2}; do
                kubectl exec --stdin=true --tty=true vault-$i -- vault operator unseal $VAULT_UNSEAL_KEY
            done
    else
        echo -e "\n${YELLOW}* Vaults have already unsealed${NC}"
    fi
}

function seal_vaults  {
    err_code=0
    for i in {0..2}; do
        kubectl exec --stdin=true  --tty=true vault-0 -- vault operator key-status 2> 1 >/dev/null
        ((err_code+=$?))
    done
    kubectl exec --stdin=true  --tty=true vault-0 -- vault operator key-status 2> 1 >/dev/null
    if [ $err_code -eq "0" ]; then
        echo -e "\n${YELLOW}* Seal all vaults${NC}"
            for i in {0..2}; do
                echo "vault-$i:"
                vault_login $i
                sleep 6
                kubectl exec --stdin=true --tty=true vault-$i -- vault operator seal
                echo ""
            done
    else
        echo -e "\n${YELLOW}* Vaults have already sealed${NC}"
    fi
}

function vault_login {
    index=$1
    echo -e "\n${YELLOW}* Get root token${NC}"
    VAULT_TOKEN=`cat cluster-keys.json | jq -r ".root_token"`
    
    echo -e "${YELLOW}* Vault login${NC}"
    kubectl exec --stdin=true --tty=true vault-$index -- vault login $VAULT_TOKEN 1>/dev/null

}

function add_new_key {
    
    kubectl exec --stdin=true  --tty=true vault-0 --  vault secrets list -format table  | awk '{print $1}' | grep "^$ROOT_DIR/" 1>/dev/null
    if [ "$?" -ne "0" ]; then
      echo -e "\n${YELLOW}* create <root directory> for secrets\n${NC}"
      kubectl exec --stdin=true  --tty=true vault-0 -- \
      vault secrets enable -path=$ROOT_DIR kv-v2 
    else
      echo "\nPATH: $ROOT_DIR/ exist in the vault"
    fi

    echo -e "${YELLOW}* Add new secrret with <path to secret> and keys <username>, <password>${NC}"
    kubectl exec --stdin=true  --tty=true vault-0 -- \
    vault kv put $ROOT_DIR/$PATH_TO_SECRET/config username=$USERNAME password=$PASSWORD

    echo -e "${YELLOW}* Show created key${NC}"
    kubectl exec --stdin=true  --tty=true vault-0 -- \
    vault kv get $ROOT_DIR/$PATH_TO_SECRET/config
}

function allow_access_from_kubernetes  {

    echo -e "\n${YELLOW}* Enable kubectl proxy${NC}"
    kubectl proxy &
    sleep 3
    echo -e "${YELLOW}* Get URL for ISSUER${NC}"
    ISSUER=`curl --silent http://127.0.0.1:8001/.well-known/openid-configuration | jq -r .issuer`
    echo "issuer=$ISSUER"
    kill %%

    kubectl exec --stdin=true  --tty=true vault-0 -- vault  auth list | awk '{print $1}' | grep "^kubernetes/" 1>/dev/null
    if [ "$?" -ne "0" ]; then
        echo -e "${YELLOW}* Enable vault authentification to kubernetes${NC}"
        kubectl exec --stdin=true  --tty=true vault-0 -- vault auth enable kubernetes
    fi

    echo -e "${YELLOW}* Vault add credentials with kubernetes cluster${NC}"  
    kubectl exec --stdin=true  --tty=true vault-0 -- sh -c '
    vault write auth/kubernetes/config \
    kubernetes_host="https://$KUBERNETES_PORT_443_TCP_ADDR:443" \
    token_reviewer_jwt="$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" \
    kubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt disable_iss_validation=true \
    issuer="$ISSUER"'
}

function add_vault_policy  {
    
    echo -e "\n${YELLOW}* Add service account key${NC}"
    kubectl create sa $SERVICE_ACCOUNT


    echo -e "${YELLOW}* Create new policy for created secret${NC}"  
    kubectl exec --stdin=true  --tty=true vault-0 -- \
    vault policy write $POLICY_NAME - <<EOF
path "secret/*" {
  capabilities = ["read"]
}
EOF
    
    echo -e "\n${YELLOW}* Apply policy for kubernetes${NC}"  
    kubectl exec --stdin=true  --tty=true vault-0 -- vault write auth/kubernetes/role/$ACCESS_ROLE \
    bound_service_account_names=$SERVICE_ACCOUNT \
    bound_service_account_namespaces=$NAMESPACE \
    policies=$POLICY_NAME \
    ttl=24h
    
}

function gen_patch_file {

    patch=$(cat <<EOF
spec:
  template:
    metadata:
      annotations:
        vault.hashicorp.com/agent-inject: 'true'
        vault.hashicorp.com/role: '$ACCESS_ROLE'
        vault.hashicorp.com/agent-inject-secret-database-config.txt: '$ROOT_DIR/$PATH_TO_SECRET/config'
        vault.hashicorp.com/log-level: "debug"
EOF
)
    printf "$patch" > patch-inject-secrets.yaml
    echo -e "\n* file patch-inject-secrets.yaml with injection has generated\n  for patching your deployment use this COMMAND: \n\n \
kubectl patch deployment <deployment name> --patch \"\$(cat patch-inject-secrets.yaml)\"\n${NC}"
}


usage=$(cat <<EOF
Usage: ./k8s_vault <arg1> <arg2> <arg3> <arg4> ... <arg10>

Arguments:
--add_repos                       add helm repo hashicorp
--install_consul                  install consul for vault via helm
--install_vault                   install vault via helm
--init_vault                      initialization vault
--unseal_vaults                   unseal all vaults
--seal_vaults                     seal vaults
--vault_login                     get password and login into vault
--add_new_key                     add secret new key in vault
--allow_access_from_kubernetes    allow access from kubernetes
--add_vault_policy                add vault policy
--all_steps                       perform all steps
--port-forward                    enable port forwarding for vault
--gen_patch_file                  generate file with patch for injection
EOF
)

for arg in "$@"
do
    case $arg in
        --add_repos)                        add_repos;;
        --install_consul)                   install_consul;;
        --install_vault)                    install_vault;;    
        --init_vault)                       init_vault;;
        --unseal_vaults)                    unseal_vaults ;;
        --seal_vaults)                      seal_vaults ;;
        --vault_login)                      vault_login "0" && echo -e "${YELLOW}* Succesfully have logined\n${NC}";;
        --add_new_key)                      add_new_key;;
        --allow_access_from_kubernetes)     allow_access_from_kubernetes;;
        --add_vault_policy)                 add_vault_policy;;
	    --port-forward)                     kubectl port-forward vault-0 8200:8200;;
        --gen_patch_file)                   gen_patch_file;;

        --all_steps)                        add_namespace && \
                                            add_repos && \
                                            install_consul && \
                                            install_vault && \
                                            init_vault && \
                                            unseal_vaults && \
                                            vault_login  "0" && echo -e "${YELLOW}* Succesfully have logined\n${NC}" && \
                                            add_new_key && \
                                            allow_access_from_kubernetes && \
                                            add_vault_policy && \
                                            gen_patch_file;;
        *)                                  printf "$usage\n${NC}" ;;
    esac
done
